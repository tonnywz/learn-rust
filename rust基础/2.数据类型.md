# 原生类型

rust 是静态类型语言，rust 在编译时就必须知道所有变量的类型。我们也说 rust 是一种强类型语言区别于 js，python 这样的弱类型语言。在使用一个变量时必须要让 rust 知道这个变量的数据类型是什么。不同的数据类型有不同的数据处理方式。  
rust 的内置原生类型有以下几类：  
整型  
浮点型  
布尔类型  
字符类型  
元组  
数组  
切片  
指针  
函数  
元类型

### 整型

rust 提供了不同长度的整型，长度分别为 8bit，16bit，32bit，64bit，128bit，arch(类型长度依赖计算机的架构。如果是 32 位的系统，那么长度就是 32 位。如果是 64 位系统，长度就是 64 位)这些不同长度的又可以分为有符号和无符号。

8bit 对应的类型：_i8_(有符号)， _u8_(无符号)

16bit 对应的类型：_i16_(有符号)， _u16_(无符号)

32bit 对应的类型：_i32_(有符号)， _u32_(无符号)

64bit 对应的类型：_i64_(有符号)， _u64_(无符号)

128bit 对应的类型：_i128_(有符号)， _u128_(无符号)

arch 对应的类型：_isize_(有符号)， _usize_(无符号)

#### 有符号与无符号的区别：

无符号的整型只能表示自然数即非负整数，有符号的整型可以表示负数。他们的取值范围与他们的长度有关。  
有符号的整型表示范围为 [−2<sup>n−1</sup>，2<sup>n-1</sup>−1]  
无符号的整型表示范围为 [0， 2<sup>n</sup>-1]
计算机操作系统中数据度量最小的单位是 bit(字位)，一个 bit 代表 0 或 1。byte(字节)是信息量单位。1byte=8bit。

#### _例如_：i8 与 u8 的取值范围

i8 的取值范围是[−2<sup>7</sup>，2<sup>7</sup>−1]，即 i8 的取值范围是[-128，127]  
u8 的取值范围是[0， 2<sup>8</sup>-1]，即 u8 的取值范围是[0，255]  
在开发过程中要充分的考虑到数值的范围，如果超出则会造成整型溢出。

```
fn main() {
    // 声明一个变量a，并将值10赋值给了a。
    // 由于声明的时候没有指定变量a具体的数据类型，rust根据值10推导变量a的类型为i32整型，rust整型默认数据类型为i32。
    let a = 10;
    println!("a => {}", a);

    // 声明一个i8的整型变量b，并将值15赋值给了b。
    // mut是mutable(可变)的缩写，在声明变量是加上mut，表明该变量接下来可以被重复赋值。
    let mut b: i8 = 15;
    println!("b => {}", b);

    // 上面介绍了i8类型的取值范围是[-128，127]，如果将128赋值给b，就会导致整型溢出。
    // rust在编译的过程会检查并报错，这也突出了rust强调的数据安全性，好奇的小伙伴可以尝试一下。
    b = 31;
    println!("b => {}", b);

    // 这里的下划线暂时理解为占位符，在整型中没有特殊含义。
    let c: u32 = 1_2_3_456;
    println!("c => {}", c); // 123456

    // 将d对应的ASCII码赋值给d，rust还可以指定单字节字符，仅限制于ASCII字符。
    let mut d = b'd';
    println!("d => {}", d); // 100
    d += 1;
    // Rust不提供原生类型之间的隐式转换，只能使用as关键字显式转换。
    println!("d => {}", d as char); // e
}
```

### 浮点型

浮点类型与整型不同的是，浮点类型是带小数点的数字。rust 的浮点类型主要有两个 f32 和 f64，长度分别是 32bit 和 64bit，默认类型是 f64，因为现在的 CPU 中 f64 与 f32 运算的速度几乎相同，f64 的精度要更高。

```
fn main() {
    // 声明一个变量a，并将值123.0赋值给变量a。
    // rust根据值123.0推导变量a的类型为f64浮点类型，rust浮点类型默认为f64。
    let a = 123.0;
    println!("a => {}", a);

    // 声明一个f64的浮点类型的变量b，并将值123。0赋值给b。
    let b: f64 = 123.0;
    println!("b => {}", b);

    // 声明一个浮点类型的变量c，并将值123.0赋值给a。
    // 这里指定了值132.0的数据类型，所以c的类型也为f64。
    let c = 123.0f64;
    println!("c => {}", c);

    // 声明一个f32的浮点类型的变量e，并将值123.0的f32浮点类型赋值给e。
    // 在声明的过程中，如果等号两边都显式的指定了类型，那边类型必须一致。
    let e: f32 = 123.0f32;
    println!("e => {}", e);
}
```

### 布尔类型

rust 语言也有布尔类型，同大多数编程语言一样，rust 语言的布尔型值也只有 true 和 false。

```
fn main() {
    // 声明一个变量a，rust根据值true推导变量a的类型为布尔并将值true赋值给变量a。
    let a = true;
    println!("a => {}", a);

    // 声明一个变量b，等号右边是一个表达式1>2，rust会根据表达式的结果false并推导变量b的类型为布尔类型，并将false赋值给变量a。
    let b = 1 > 2;
    println!("b => {}", b);

    // 声明一个布尔类型的变量c，并将值false赋值给变量c。
    let c: bool = false;
    println!("c => {}", c);
}
```

### 字符类型

rust 语言也有字符类型，表示单个 Unicode 字符，存储为 4 个字节。(char 由单引号指定，不同于字符串使用双引号)

```
fn main() {
    // 声明一个字符类型的变量a，并将值'a'赋值给变量a。
    // 注意这里的值'a'须用''单引号，如果使用""双引号怎是另外一种类型 -- string
    let a: char = 'a';
    println!("a => {}", a);

    // 声明一个变量b，由于没有指定b具体的数据类型，rust跟值'b'推导变量b的类型为字符类型
    let b = 'b';
    println!("b => {}", b);
}
```

### 元组

元组(tuples)是大小固定的有序列表，且其中的每个元素 _类型不一定相同_ ，需要通过解构或者索引来获取其中的元素的值。元素数量不多于 12 个的元组值传递时是自动复制的。

```
fn main() {
    // 元组声明可以显式的指定其中元素的类型
    let a: (i32, char, f64) = (111, 'a', 123.0);
    // 元组是复合类型需要使用{:?}格式化符
    println!("a => {:?}", a);
    // 使用元组解构赋值,b对应的元组a中第一个值111
    let (b, c, d) = a;
    println!("b => {}", b); // 111
    println!("c => {}", c); // a
    println!("d => {}", d); // 123.0
    // 使用索引获取元组中元素的值,使用方法：元组名.索引数字
    println!("a.0 => {} a.1 => {} a.2 => {}", a.0, a.1, a.2);
    // 元组声明根据根据复制的类型推导
    let e = (1, '2', 3.0f32);
    println!("e => {:?}", e);
}
```

### 数组

数组在内存上是一段连续空间，与 C 中的数组类似，数组中的元素类型都相同，所以根据元素的数据类型以及元素的数量可以判断出这个内存块的体积大小，数组中的元素是依次存放的，可以存放的顺序代表元素的数组中的位置，这个位置叫做数组下标。所以 rust 中的数组是静态的,大小固定的,有序的列表，且其中的元素的 _类型相同_ ，可表示为[T; N]。元素数量不多于 32 个的数组值传递时是自动复制的。

```
fn main() {
    // 声明一个数组a，并指定a中的元素的数据类型为i32以及长度为9。并将数组a中的元素全部初始化为0。
    let a: [i32; 3] = [0; 3];
    // a.len() 函数用于返回数组a的长度
    println!("a size is => {}", a.len()); // 3
    println!("a => {:?}", a);

    // 声明一个数组a，根据值推导出数组中的元素类型为整型(默认为i32)，数组长度为9。
    let b = [0; 9];
    println!("b => {:?}", b);

    // 声明一个数组a，并指定了数组中的每个元素的初始值。
    let c = [1, 2, 3];
    println!("c => {:?}", c);

    // 通过数组下标的方式遍历数组a。
    // 0..a.len()会生成一个0到a.len()的迭代器,这个迭代器是由0到a.len()的数字组成的。
    for i in 0..a.len() {
        println!("a[{}] => {}", i, a[i])
    }

    // a.iter()函数为数组a生成一个迭代器，是有数组a的元素组成的。
    for v in a.iter() {
        println!("v => {}", v)
    }

    // 声明一个可变的数组，指定数组长度为4，其中元素全部初始化为0。
    // 可变数组只能改变数组内元素的值，不能执行添加元素和删除元素，不能修改数组长度。数组的长度在数组声明时就已经分配好了内存空间。
    let mut e = [0; 4];
    println!("e => {:?}", e);
    // 遍历数组，重新给数组内的元素赋值
    for i in 0..e.len() {
        e[i] = i
    }
    println!("e => {:?}", e);

    // 声明数组时数组的长度可以使用字面量或常量，而不能使用let声明的变量，尽管只是可读变量。
    const LENGTH: usize = 5;
    let f = [0; LENGTH];
    println!("f => {:?}", f);
}
```

### 切片

切片是对一个数组部分数据的引用，且不需要拷贝，可表示为&[T]。可以理解为该数组片段的的头指针，对一个切片中的某个元素的值的修改，其被引用的数组的对应的值也会被修改。

### 指针

指针是一个包含内存地址的变量，在 rust 中，指针包括引用(`&T`和`&mut T`)、裸指针(`*const T` 和`*mut T`)、可变和不可变引用(`&mut T`和`&T`)和智能指针(`Box<T>`、`Rc<T>`、 `Arc<T>`、`Cell<T>`、`RefCell<T>` 、`UnsafeCell<T>` 等)，裸指针解引用它们是不安全的，必须放到 unsafe 块里。

#### 引用

引用就是将获取引用作为函数参数称为借用，直接对一个变量执行 `&`、`&mut` 操作，永远不会为 null。指针的大小 usize 一致,保存的是被引用变量的地址。与引用相关的一个名词是 借用(borrowing)。

#### 裸指针

#### 智能指针

#### 引用

### 函数

函数是具有函数类型的变量实质上是一个函数指针。

### 元类型

元类型即()，其唯一的值也是()
