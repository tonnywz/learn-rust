# 数据类型

rust 是静态类型语言，rust 在编译时就必须知道所有变量的类型。我们也说 rust 是一种强类型语言区别于 js，python 这样的弱类型语言。在使用一个变量时必须要让 rust 知道这个变量的数据类型是什么。不同的数据类型有不同的数据处理方式。  
原生类型：

- 整型
- 浮点型
- 布尔类型
- 字符类型
- 元组
- 数组
- 切片
- 指针
- 函数
- 元类型

还有介绍一些其他的经常会用到的数据类型：

- 动态数组
- 字符串

---

## 整型

rust 提供了不同长度的整型，长度分别为 8bit，16bit，32bit，64bit，128bit，arch（类型长度依赖计算机的架构。如果是 32 位的系统 32bit。如果是 64 位系统 64bit）这些不同长度的又可以分为有符号和无符号。

8bit 对应的类型：_i8_(有符号)， _u8_(无符号)

16bit 对应的类型：_i16_(有符号)， _u16_(无符号)

32bit 对应的类型：_i32_(有符号)， _u32_(无符号)

64bit 对应的类型：_i64_(有符号)， _u64_(无符号)

128bit 对应的类型：_i128_(有符号)， _u128_(无符号)

arch 对应的类型：_isize_(有符号)， _usize_(无符号)

### 有符号与无符号的区别：

无符号的整型只能表示自然数即非负整数，有符号的整型可以表示负数。他们的取值范围与他们的长度有关。  
**有符号的整型**表示范围： [−2<sup>n−1</sup>，2<sup>n-1</sup>−1]  
**无符号的整型**表示范围： [0， 2<sup>n</sup>-1]  
_计算机操作系统中数据度量最小的单位是 bit(字位)，一个 bit 代表 0 或 1。byte(字节)是信息量单位。1byte=8bit。_

> _例如_：i8 与 u8 的取值范围：  
> i8 的取值范围是[−2<sup>7</sup>，2<sup>7</sup>−1]，即 i8 的取值范围是[-128，127]  
> u8 的取值范围是[0， 2<sup>8</sup>-1]，即 u8 的取值范围是[0，255]  
> 在开发过程中要充分的考虑到数值的范围，如果超出则会造成整型溢出。

### 整型溢出

在调试模式下编译器会对整型溢出检查，如果发生了整型溢出编译器会抛出一个 `panic` 后终止编译。如果在 release 模式下（即编译命令添加`--release`标签）rust 不会对整型溢出进行检查，如果发生了整型溢出，rust 会进行二进制补码。

> 以 u8 为例：  
> 如果有声明了一个变量指定它的类型为 u8，上面介绍了 u8 的取值范围是[0，255]，如果将 256 赋值给这个变量，那么这个变量的值将变成 0。是不是很神奇？这里解释一下，u8 的长度是 8 字节，即八位二进制。二进制是由`0`和`1`组成。所以 u8 的取值范围由二进制来表示的话就是[00000000,11111111]。
> 二进制`111111111`转换成十进制就是`255`，而`256`的二进制是`100000000`，256 的二进制需要 9 个字节来表示，而 u8 只有八个字节来表示，在`--release`模式下，如果将 256 赋值给一个数据类型为 u8 的变量时，这个变量只能接收到 1`00000000`的后面的八位，即把`00000000`赋值给了变量，而`00000000`转换为十进制就是`0`。

```
fn main() {
    // 声明一个变量a，并将值10赋值给了a。
    // 由于声明的时候没有指定变量a具体的数据类型，rust根据值10推导变量a的类型为i32整型，rust整型默认数据类型为i32。
    let a = 10;
    println!("a => {}", a);

    // 声明一个i8的整型变量b，并将值15赋值给了b。
    // mut是mutable(可变)的缩写，在声明变量是加上mut，表明该变量接下来可以被重复赋值。
    let mut b: i8 = 15;
    println!("b => {}", b);

    // 上面介绍了i8类型的取值范围是[-128，127]，如果将128赋值给b，就会导致整型溢出。
    // rust在编译的过程会检查并报错，这也突出了rust强调的数据安全性，好奇的小伙伴可以尝试一下。
    b = 31;
    println!("b => {}", b);

    // 这里的下划线暂时理解为占位符，在整型中没有特殊含义。
    let c: u32 = 1_2_3_456;
    println!("c => {}", c); // 123456

    // 将d对应的ASCII码赋值给d，rust还可以指定单字节字符，仅限制于ASCII字符。
    let mut d = b'd';
    println!("d => {}", d); // 100
    d += 1;
    // Rust不提供原生类型之间的隐式转换，只能使用as关键字显式转换。
    println!("d => {}", d as char); // e
}
```

---

## 浮点型

浮点类型与整型不同的是，浮点类型是带小数点的数字。rust 的浮点类型主要有两个 f32 和 f64。f32 类型是单精度浮点长度为 32bit，f64 是双精度浮点长度为 64bit。rust 浮点类型是 f64，因为现在的 CPU 中 f64 与 f32 运算的速度几乎相同，f64 的精度要更高。

```
fn main() {
    // 声明一个变量a，并将值123.0赋值给变量a。
    // rust根据值123.0推导变量a的类型为f64浮点类型，rust浮点类型默认为f64。
    let a = 123.0;
    println!("a => {}", a);

    // 声明一个f64的浮点类型的变量b，并将值123。0赋值给b。
    let b: f64 = 123.0;
    println!("b => {}", b);

    // 声明一个浮点类型的变量c，并将值123.0赋值给a。
    // 这里指定了值132.0的数据类型，所以c的类型也为f64。
    let c = 123.0f64;
    println!("c => {}", c);

    // 声明一个f32的浮点类型的变量e，并将值123.0的f32浮点类型赋值给e。
    // 在声明的过程中，如果等号两边都显式的指定了类型，那边类型必须一致。
    let e: f32 = 123.0f32;
    println!("e => {}", e);
}
```

---

## 布尔类型

rust 语言也有布尔类型，同大多数编程语言一样，rust 语言的布尔型值也只有 true 和 false。布尔类型的大小为一个 bit，即一个二进制。

```
fn main() {
    // 声明一个变量a，rust根据值true推导变量a的类型为布尔并将值true赋值给变量a。
    let a = true;
    println!("a => {}", a);

    // 声明一个变量b，等号右边是一个表达式1>2，rust会根据表达式的结果false并推导变量b的类型为布尔类型，并将false赋值给变量a。
    let b = 1 > 2;
    println!("b => {}", b);

    // 声明一个布尔类型的变量c，并将值false赋值给变量c。
    let c: bool = false;
    println!("c => {}", c);
}
```

---

## 字符类型

rust 语言也有字符类型，表示单个 Unicode 标量值，存储为 4 个字节。(char 由单引号指定，不同于字符串使用双引号)

```
fn main() {
    // 声明一个字符类型的变量a，并将值'a'赋值给变量a。
    // 注意这里的值'a'须用''单引号，如果使用""双引号怎是另外一种类型 -- string
    let a: char = 'a';
    println!("a => {}", a);

    // 声明一个变量b，由于没有指定b具体的数据类型，rust跟值'b'推导变量b的类型为字符类型
    let b = 'b';
    println!("b => {}", b);
}
```

---

## 元组

元组(tuples)是大小固定的有序列表，将多种类型的多个值组合为一个复合类型的一般方法，表现形式是通过括号`()`内用逗号`,`分隔的值的列表。需要通过解构或者索引来获取其中的元素的值。元素数量不多于 12 个的元组值传递时是自动复制的。

```
fn main() {
    // 元组声明可以显式的指定其中元素的类型
    let a: (i32, char, f64) = (111, 'a', 123.0);

    // 元组是复合类型需要使用{:?}格式化符
    println!("a => {:?}", a);

    // 使用元组解构赋值,b对应的元组a中第一个值111
    // 将a赋值给三个独立的变量b, c, d称为解构
    let (b, c, d) = a;
    println!("b => {}", b); // 111
    println!("c => {}", c); // a
    println!("d => {}", d); // 123.0

    // 使用索引获取元组中元素的值,使用方法：元组名.索引数字。元组中的第一个索引为0
    println!("a.0 => {} a.1 => {} a.2 => {}", a.0, a.1, a.2);

    // 元组声明根据赋值的类型推导
    let e = (1, '2', 3.0f32);
    println!("e => {:?}", e);
}
```

---

## 数组

数组也是将多个值集合在一起，但与元组不同，数组中的每个元素数据类型必须都一样，表现形式是通过方括号`[]`内用逗号`,`分隔的值的列表。

> 数组在内存上是一段连续空间，与 C 中的数组类似，数组中的元素类型都相同，所以根据元素的数据类型以及元素的数量可以判断出这个内存块的体积大小，数组中的元素是依次存放的，可以存放的顺序代表元素的数组中的位置，这个位置叫做数组下标。所以 rust 中的数组是静态的,大小固定的,有序的列表，且其中的元素的 _类型相同_ ，可表示为[T; N]。元素数量不多于 32 个的数组值传递时是自动复制的。

如果需要在程序中需要创建固定数量的元素时，使用数组会非常有效。如果需要对数组长度的伸缩有需求的话，可以使用动态数组 Vec 这样的矢量类型。Vec 之后会有介绍，先别心急。

> 创建数组

创建一个简单数组

```
fn main() {
    // 声明一个数组变量a，指定的数组中每个元素的数据类型为i32，数组的长度为5。等号右边是要赋值给变量a的值，值的顺序就是它们以后在数组中的顺序
    // 等号右侧的的元素数量要与等号左边的数组长度一致
    let a: [i32; 5] = [1, 2, 3, 4, 5];
    println!("a => {:?}", a);
}
```

rust 为数组提供了`len()`方法，用于返回数组的长度

```
fn main() {
    let a = [1, 2, 3, 4, 5];
    println!("a => {:?}", a.len());
}
```

默认值初始化一个数组

```
fn main() {
    // 数组中的所有元素初始化为相同的值，可以使用等号右边的方法，[初始值;元素数量]
    let a: [i32; 5] = [0; 5];
    println!("a => {:?}", a);
}

```

数组初始化时忽略元素数据类型以及数组长度，rust 会根据值推导数据类型以及长度。

```
fn main() {
    let a = [100; 3];
    println!("a => {:?}", a);
}
```

创建可变数组,只能改变数组内元素的值，不能对执行添加或删除元素，即数组的长度不能改变。数组的长度在数组声明时就已经分配好了内存空间。

```
fn main() {
    let mut a = [0; 4];
    println!("a => {:?}", a);
    // 遍历数组，重新给数组内的元素赋值
    for i in 0..a.len() {
        a[i] = i
    }
    println!("a => {:?}", a);
}
```

创建数组时，数组长度只能是字面量或常量，而不能使用 let 声明的变量，尽管只是可读变量。

```
fn main() {
    // 声明常量
    const LENGTH: usize = 5;
    let a = [0; LENGTH];
    println!("a => {:?}", a);
}
```

> 访问数组元素

访问数组中的元素是通过数组下标来访问的。数组中的元素都是按照顺序依次存储的，顺序的序号就代表着元素在数组中的位置，这个顺序的序号就叫做数组下标，下标从 0 开始。数组的第一个元素的下标是 `0`，最后一个元素的下标是`数组的长度-1`。如果访问的位置不在这个范围内会发生下标越界，编译时会通过但在运行时 rust 尝试访问一个不在这个数组内的元素时会报错后立即退出程序，而不会像其他语言那样允许访问一个无效的内存。

```
fn main() {
    let a: [i32; 5] = [1, 2, 3, 4, 5];
    // 通过数组下标的方式遍历数组a。
    println!("a[0] => {}", a[0]);
}
```

> 通过数组下标 for in 循环遍历数组，rust 与其他语言一样也有 for 循环

```
fn main() {
    let a = [0; 5];
    // 0..a.len()会生成一个0到a.len()的迭代器,这个迭代器是由0到a.len()的数字按照顺序组成的。
    for i in 0..a.len() {
        println!("a[{}] => {}", i, a[i])
    }
}
```

> rust 为数组提供了`iter()`函数为数组生成一个迭代器，可以使用 for in 来迭代数组

```
fn main() {
    let a = [0; 5];
    for v in a.iter() {
        println!("v => {}", v)
    }
}
```

---

## 切片

切片是对一个数组部分数据的引用，且不需要拷贝，可表示为&[T]，切片可以引用这个整个数据也可以引用部分数组，可以把切片看作是被应用数组的子集。切片的大小是在编译时获得的。

对整个数组的引用

```
fn main() {
    let a = [1, 2, 3, 4, 5];
    println!("a => {:?}", a);

    let b = &a;
    println!("b => {:?}", b);
}
```

对部分数组的引用是通过数组下标,引用的位置为一个左闭右开区间，同样引用位置不能越界。引用位置左边缺省情况下默认为 `0`，右边缺省情况下默认为`数组长度`。

```
fn main() {
    let a = [1, 2, 3, 4, 5];
    println!("a => {:?}", a);

    let b = &a[2..4];
    println!("b => {:?}", b); // [3, 4]

    // 左边缺省
    let c = &a[..4];
    println!("c => {:?}", c); // [1, 2, 3, 4]

    // 右边缺省
    let d = &a[2..];
    println!("d => {:?}", d); // [3, 4, 5]
}
```

通过`&mut`对`mut`数组引用，对切片元素值得修改会直接作用到被引用得数组中对应得元素。其本质是切片的本身是指针，指向的是被引用的元素的内存地址。直接访问切片的元素其实就是在访问被引用数组内对应的元素。

```
fn main() {
    let mut a = [1, 2, 3, 4, 5];
    println!("a => {:?}", a[2]); // 3

    let b = &mut a[2..4];
    println!("b => {}", b[0]); // 3
    b[0] = 100;
    println!("a => {:?}", a[2]); // 100
}
```

---

## 指针

指针是一个包含内存地址的变量，在 rust 中，指针包括：

- 引用(`&T`和`&mut T`)
- 胖指针(`&[T] `)
- 裸指针(`*const T` 和`*mut T`)
- 智能指针(`Box<T>`、`Rc<T>`、 `Arc<T>`、`Cell<T>`、`RefCell<T>` 、`UnsafeCell<T>` 等)。

---

### 引用

引用就是将获取引用作为函数参数称为借用，直接对一个变量执行 `&`、`&mut` 操作，永远不会为 null。指针的大小与 usize 一致,保存的是被引用变量的地址。与引用相关的一个名词是 借用(borrowing)。
引用可以使用借用操作符`&`来创建，类似于在

> ### 胖指针

胖指针与引用类似，引用借用的是单一变量，而胖指针则可以借用的是多个变量，可以是多个变量。_切片_ 属于胖指针，其指针包括两个部分，一部分用来保存被引用变量的地址，另一部分数据的保存长度。

> ### 裸指针

裸指针解引用它们是不安全的，必须放到 unsafe 块里。

> ### 智能指针

---

## 函数

函数是具有函数类型的变量实质上是一个函数指针。

---

## 元类型

元类型即()，其唯一的值也是()

```

```
